<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Liquid Glass Chat - Optimized</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Emoji Picker Library -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
    <style>
        /* --- FULL OPTIMIZATION APPLIED: Replaced ALL GPU-heavy blur with fake glass effect --- */
        :root {
            --glass-primary: rgba(255, 255, 255, 0.08);
            --glass-secondary: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-shadow: 0 6px 16px 0 rgba(31, 38, 135, 0.35); 
            --bubble-me: rgba(0, 122, 255, 0.8);
            --bubble-rumaisa: rgba(255, 255, 255, 0.15);
            --text-primary: rgba(255, 255, 255, 0.9);
            --text-secondary: rgba(255, 255, 255, 0.7);
        }

        * {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
        }

        body {
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%);
            position: relative;
        }

        /* Main container with liquid glass effect */
        .chat-container {
            width: 100vw;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--glass-primary);
            border: 1px solid var(--glass-border);
            position: relative;
            z-index: 1;
        }

        /* Liquid Glass Header */
        .chat-header {
            background: var(--glass-primary);
            border-bottom: 1px solid var(--glass-border);
            color: var(--text-primary);
            padding: 1.25rem 1rem;
            text-align: center;
            box-shadow: var(--glass-shadow);
            z-index: 30;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .chat-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 3s ease-in-out infinite;
        }
        
        #signal-light {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: currentColor;
            transition: color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 10px 2px currentColor;
        }
        #signal-light.red { color: #ef4444; }
        #signal-light.yellow { color: #facc15; }
        #signal-light.green { color: #10b981; }

        .profile-link {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s ease;
            display: inline-flex;
            align-items: center;
        }
        .profile-link:hover {
            color: var(--text-primary);
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0; transform: translateX(-100%); }
            50% { opacity: 1; transform: translateX(100%); }
        }

        /* Chat messages area */
        .chat-box {
            flex: 1;
            padding: 1rem;
            padding-bottom: calc(1rem + 6rem + env(safe-area-inset-bottom, 0));
            overflow-y: auto;
            scroll-behavior: smooth;
            position: relative;
            background: transparent;
        }

        /* Enhanced message bubbles with liquid glass */
        .message {
            max-width: 75%;
            margin: 0.75rem 0;
            padding: 1rem 1.25rem;
            border-radius: 2rem;
            clear: both;
            word-wrap: break-word;
            position: relative;
            animation: liquidAppear 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            white-space: pre-wrap;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
            user-select: none;
            cursor: pointer;
        }

        .me { 
            background: var(--bubble-me);
            color: white; 
            margin-left: auto; 
            border-bottom-right-radius: 0.75rem;
            box-shadow: var(--glass-shadow), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .rumaisa { 
            background: var(--bubble-rumaisa);
            color: var(--text-primary); 
            margin-right: auto; 
            border-bottom-left-radius: 0.75rem;
            box-shadow: var(--glass-shadow), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .message:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 10px 24px 0 rgba(31, 38, 135, 0.45);
        }
        
        @keyframes liquidAppear {
            from { transform: translateY(1.5rem) scale(0.9); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        .message-time { 
            font-size: 0.7rem; 
            opacity: 0.6; 
            margin-top: 0.5rem; 
            float: right; 
            margin-left: 1rem;
            color: var(--text-secondary);
        }
        
        .media { 
            display: block; max-width: 100%; border-radius: 1.25rem; margin: 0;
            cursor: pointer; object-fit: cover; box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            transition: all 0.3s ease; border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .message .media + .message-text-content {
            margin-top: 0.75rem;
        }
        .media:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 32px rgba(0,0,0,0.3);
        }
        .media-video { 
            display: block; width: 100%; max-height: 280px; border-radius: 1.25rem; 
            margin: 0; box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Liquid Glass Input Bar */
        .input-box {
            position: fixed;
            left: 0;
            right: 0;
            bottom: env(safe-area-inset-bottom, 0);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0.75rem;
            background: var(--glass-primary);
            border-top: 1px solid var(--glass-border);
            flex-shrink: 0;
            z-index: 50;
            box-shadow: var(--glass-shadow);
            position: relative;
            overflow: hidden;
        }

        .input-box::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }

        .input-content-wrapper { 
            display: flex; align-items: flex-end; width: 100%; max-width: 800px; 
            gap: 0.75rem; padding: 0 0.5rem; 
        }

        .input-area-container { display: flex; flex-direction: column; flex-grow: 1; gap: 0.5rem; }

        .message-input-wrapper { 
            flex: 1; display: flex; align-items: center; 
            background: var(--glass-secondary);
            border-radius: 2rem; 
            border: 1px solid var(--glass-border);
            min-height: 3rem; 
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1), var(--glass-shadow);
            transition: all 0.3s ease; position: relative; overflow: hidden;
        }
        .message-input-wrapper:focus-within {
            border-color: rgba(0, 122, 255, 0.5);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1), 0 0 0 2px rgba(0, 122, 255, 0.2);
        }

        .message-input { 
            flex: 1; border: none; background: transparent; 
            padding: 0.75rem 1rem; font-size: 1rem; outline: none; resize: none; 
            max-height: 8rem; color: var(--text-primary); font-family: inherit;
        }
        .message-input::placeholder { color: var(--text-secondary); }

        .send-button, .plus-button, .emoji-button, .voice-button { 
            width: 3rem; height: 3rem; border-radius: 50%; display: flex; 
            justify-content: center; align-items: center; color: white; 
            font-size: 1.25rem; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
            box-shadow: var(--glass-shadow); border: 1px solid var(--glass-border);
            position: relative; overflow: hidden;
            flex-shrink: 0;
        }
        .emoji-button { font-size: 1.5rem; }

        .send-button, .voice-button { background: var(--bubble-me); }
        .plus-button, .emoji-button { background: var(--glass-primary); color: var(--text-primary); }

        .send-button:hover:not(:disabled), .plus-button:hover, .emoji-button:hover, .voice-button:hover { 
            transform: scale(1.1) translateY(-2px); 
            box-shadow: 0 12px 32px rgba(0, 122, 255, 0.4);
        }

        .send-button:disabled { 
            background: var(--glass-secondary); color: var(--text-secondary); 
            cursor: not-allowed; box-shadow: none; 
        }
        
        .file-info-bar {
            display: none; width: 100%; padding: 0.75rem 1rem;
            background: var(--glass-secondary);
            border-radius: 1.25rem; align-items: center; justify-content: space-between;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: var(--glass-shadow); border: 1px solid var(--glass-border);
            animation: liquidSlideIn 0.4s ease-out;
        }
        .file-info-bar.show { display: flex; }
        @keyframes liquidSlideIn {
            from { opacity: 0; transform: translateY(1rem) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        #sentNotification {
            position: fixed; top: -100px; left: 50%; transform: translateX(-50%);
            padding: 1rem 2rem;
            background: var(--glass-primary);
            border: 1px solid var(--glass-border); border-radius: 2rem;
            box-shadow: var(--glass-shadow); color: var(--text-primary); font-weight: 600;
            z-index: 100; display: flex; align-items: center; gap: 0.75rem;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); opacity: 0;
        }

        #sentNotification.show { top: 2rem; opacity: 1; animation: notificationPulse 0.6s ease-out; }

        @keyframes notificationPulse {
            0% { transform: translateX(-50%) scale(0.8); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }

        .load-more {
            background: var(--glass-primary);
            border: 1px solid var(--glass-border); color: var(--text-primary);
            padding: 0.75rem 1.5rem; border-radius: 1.5rem; margin: 1rem auto;
            cursor: pointer; transition: all 0.3s ease; box-shadow: var(--glass-shadow); text-align: center;
        }

        .load-more:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 12px 32px rgba(0, 122, 255, 0.2); }

        .modal-container { 
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; 
            overflow: auto; background: rgba(0, 0, 0, 0.8);
            justify-content: center; align-items: center; animation: modalFadeIn 0.3s ease-out; 
        }

        @keyframes modalFadeIn { from { opacity: 0; } to { opacity: 1; } }

        .modal-content { 
            max-width: 90vw; max-height: 90vh; border-radius: 1rem;
            box-shadow: var(--glass-shadow);
            animation: modalZoom 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
        }

        @keyframes modalZoom {
            from { transform: scale(0.7) rotate(5deg); opacity: 0; }
            to { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .close-modal-btn { 
            position: absolute; top: 1rem; right: 2rem; color: white; font-size: 2rem; 
            font-weight: bold; cursor: pointer;
            background: var(--glass-primary);
            border: 1px solid var(--glass-border); border-radius: 50%;
            width: 3rem; height: 3rem; display: flex; align-items: center; justify-content: center;
            box-shadow: var(--glass-shadow); transition: all 0.3s ease;
        }

        .close-modal-btn:hover { transform: scale(1.1) rotate(90deg); background: rgba(255, 59, 48, 0.8); }

        .date-separator span {
            background: var(--glass-primary);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            padding: 0.5rem 1rem; border-radius: 1rem; font-size: 0.75rem; font-weight: 600;
            box-shadow: var(--glass-shadow);
        }

        .chat-box::-webkit-scrollbar { width: 4px; }
        .chat-box::-webkit-scrollbar-track { background: transparent; }
        .chat-box::-webkit-scrollbar-thumb { background: var(--glass-border); border-radius: 2px; }
        .chat-box::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.4); }

        .file-message { 
            display: flex; align-items: center; padding: 1rem; 
            background: var(--glass-secondary);
            border-radius: 1rem; margin: 0.5rem 0; cursor: pointer; transition: all 0.3s ease;
            border: 1px solid var(--glass-border); box-shadow: var(--glass-shadow);
        }
        .file-message:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 12px 32px rgba(0, 122, 255, 0.2); }
        .file-icon { font-size: 1.5rem; margin-right: 0.75rem; color: var(--text-primary); }
        .reply-preview { padding: 0.5rem 0.75rem; margin-bottom: 0.5rem; border-radius: 0.75rem; background: rgba(0,0,0,0.1); display: flex; gap: 0.5rem; border: 1px solid rgba(255,255,255,0.05); }
        .reply-bar { width: 2px; background-color: var(--bubble-me); border-radius: 1px; flex-shrink: 0; }
        .message.rumaisa .reply-bar { background-color: var(--text-secondary); }
        .reply-content { font-size: 0.8rem; line-height: 1.2; overflow: hidden; }
        .reply-sender { font-weight: 600; color: var(--bubble-me); }
        .message.rumaisa .reply-sender { color: var(--text-primary); }
        .reply-text { opacity: 0.8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .reactions-container {
            position: absolute; bottom: -0.75rem; right: 0.75rem; display: flex; gap: 0.25rem;
            background: var(--glass-secondary);
            padding: 0.25rem 0.5rem; border-radius: 1rem; border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow); transform: scale(0);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: bottom right; z-index: 10;
        }
        .message.me .reactions-container { right: auto; left: 0.75rem; transform-origin: bottom left; }
        .reactions-container.visible { transform: scale(1); }
        .reaction-pill { font-size: 0.75rem; display: flex; align-items: center; }
        #messageActionMenu { transition: opacity 0.2s ease, transform 0.2s ease; }
        .context-action-btn {
            display: flex; align-items: center; padding: 0.5rem 1rem; border-radius: 0.375rem;
            width: 100%; text-align: left; color: var(--text-primary);
            transition: background-color 0.2s ease; font-size: 0.875rem; font-weight: 500;
        }
        .context-action-btn:hover { background-color: rgba(255, 255, 255, 0.1); }

        #emojiPickerContainer { position: absolute; z-index: 102; transform-origin: top left; animation: modalZoom 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        emoji-picker {
            --background: var(--glass-primary);
            --border-color: var(--glass-border);
            --outline-color: rgba(0, 122, 255, 0.5);
            --text-color: var(--text-primary);
            --secondary-text-color: var(--text-secondary);
            --border-radius: 1rem;
            --box-shadow: var(--glass-shadow);
        }

        @media (max-width: 768px) {
            .message { max-width: 85%; padding: 0.875rem 1rem; }
            .chat-header { padding: 1rem 0.75rem; }
            .input-box { padding: 0.5rem; }
        }

        .message-input:focus { outline: none; }
        .message, .send-button, .plus-button, .file-info-bar, .modal-content {
            will-change: transform, opacity;
        }
    </style>
</head>
<body>

<div class="chat-container">
    <div class="chat-header">
        <div class="flex items-center justify-center gap-3 mb-1">
            <h3 class="font-bold text-xl tracking-wide">Emon</h3>
            <span id="signal-light"></span>
        </div>
        <a href="https://emoneditz.github.io/about-me/" target="_blank" class="profile-link">
            <i class="fas fa-user-circle mr-1"></i> View Profile
        </a>
    </div>

    <div class="chat-box" id="chatBox">
        <div class="load-more" id="loadMore" style="display: none;">
            <i class="fas fa-arrow-up mr-2"></i>Load older messages
        </div>
    </div>

    <div id="sentNotification">
        <i id="sentIcon" class="fas fa-check-circle text-green-500"></i>
        <span id="sentMessage">Message sent!</span>
    </div>

    <div class="input-box" id="inputBox">
        <input type="file" id="fileInput" class="hidden" accept="image/*,video/*,.pdf,.doc,.docx,.txt">
        <div class="input-content-wrapper">
            <div class="input-area-container">
                 <div id="replyingToBar" class="file-info-bar">
                    <div class="file-details flex items-center flex-1 overflow-hidden">
                        <i class="fas fa-reply file-icon"></i>
                        <div class="flex flex-col flex-1 overflow-hidden">
                             <span id="replyingToUser" class="file-name text-white font-medium truncate flex-1"></span>
                             <span id="replyingToText" class="text-gray-300 text-xs truncate"></span>
                        </div>
                    </div>
                    <button id="replyCloseBtn" class="file-close-btn text-gray-400 hover:text-red-400 ml-3 p-1" type="button">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="fileInfoBar" class="file-info-bar">
                    <div class="file-details flex items-center flex-1 overflow-hidden">
                        <i id="fileIcon" class="file-icon"></i>
                        <span id="fileName" class="file-name text-white font-medium truncate flex-1"></span>
                        <span id="fileSize" class="file-size text-gray-300 text-xs ml-2 flex-shrink-0"></span>
                    </div>
                    <button id="fileCloseBtn" class="file-close-btn text-gray-400 hover:text-red-400 ml-3 p-1" type="button">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <!-- START: Voice Recording UI -->
                <div id="recordingBar" class="file-info-bar">
                    <div class="file-details flex items-center flex-1 overflow-hidden">
                        <i class="fas fa-microphone-alt text-red-500 animate-pulse file-icon"></i>
                        <span id="recordingTimer" class="file-name text-white font-medium">00:00</span>
                    </div>
                    <button id="cancelRecordingBtn" class="file-close-btn text-gray-400 hover:text-red-400 ml-3 p-1" type="button">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
                <!-- END: Voice Recording UI -->
                <div class="message-input-wrapper" id="messageInputWrapper">
                    <button type="button" class="plus-button" id="plusBtn" onclick="openFileDialog()">
                        <i class="fas fa-paperclip"></i>
                    </button>
                    <textarea id="msg" class="message-input" placeholder="Type a message..." rows="1"></textarea>
                </div>
            </div>
            <!-- START: Voice/Send Button Toggle -->
            <button type="button" class="voice-button" id="voiceBtn">
                <i class="fas fa-microphone"></i>
            </button>
            <button type="button" class="send-button" onclick="sendMessage()" id="sendBtn" style="display: none;">
                <i class="fas fa-paper-plane"></i>
            </button>
            <!-- END: Voice/Send Button Toggle -->
        </div>
    </div>
</div>

<div class="modal-container" id="modalContainer">
    <span class="close-modal-btn" onclick="closeModal()">&times;</span>
    <img class="modal-content" id="fullImage" src="" alt="Full size image">
</div>

<!-- Container for Emoji Picker -->
<div id="emojiPickerContainer" class="hidden absolute">
    <emoji-picker></emoji-picker>
</div>

<div id="messageActionMenu" class="hidden absolute z-[101]">
    <div id="quickReactions" class="flex items-center gap-1 bg-glass-primary backdrop-blur rounded-full shadow-lg border border-glass-border p-2 mb-2">
        <!-- Reactions will be populated by JS -->
    </div>
    <div class="flex flex-col gap-1 bg-glass-primary backdrop-blur rounded-lg shadow-lg border border-glass-border p-1">
        <button id="replyBtn" class="context-action-btn">
            <i class="fas fa-reply w-5 mr-2 text-gray-300"></i>
            <span>Reply</span>
        </button>
        <button id="copyBtn" class="context-action-btn">
            <i class="fas fa-copy w-5 mr-2 text-gray-300"></i>
            <span>Copy</span>
        </button>
        <button id="deleteBtn" class="context-action-btn">
            <i class="fas fa-trash w-5 mr-2 text-gray-300"></i>
            <span>Delete</span>
        </button>
    </div>
</div>


<script>
    const TOKEN = "8373355359:AAF0b7kWG2mNFv0qBYt2YTjvW5mD6eSBCuw";
    const CHAT_ID = "6009819572";
    const RUMAISA_ID = 6009819572; // Changed to number for strict comparison
    const chatBox = document.getElementById('chatBox');
    const loadMoreBtn = document.getElementById('loadMore');
    const modalContainer = document.getElementById('modalContainer');
    const fullImage = document.getElementById('fullImage');
    const fileInput = document.getElementById('fileInput');
    const fileInfoBar = document.getElementById('fileInfoBar');
    const fileNameDisplay = document.getElementById('fileName');
    const fileSizeDisplay = document.getElementById('fileSize');
    const fileIconDisplay = document.getElementById('fileIcon');
    const fileCloseBtn = document.getElementById('fileCloseBtn');
    const messageInput = document.getElementById('msg');
    const sendBtn = document.getElementById('sendBtn');
    const sentNotification = document.getElementById('sentNotification');
    const sentMessage = document.getElementById('sentMessage');
    const sentIcon = document.getElementById('sentIcon');
    
    const messageActionMenu = document.getElementById('messageActionMenu');
    const quickReactions = document.getElementById('quickReactions');
    const replyBtn = document.getElementById('replyBtn');
    const copyBtn = document.getElementById('copyBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const replyingToBar = document.getElementById('replyingToBar');
    const replyingToUser = document.getElementById('replyingToUser');
    const replyingToText = document.getElementById('replyingToText');
    const replyCloseBtn = document.getElementById('replyCloseBtn');
    const emojiPickerContainer = document.getElementById('emojiPickerContainer');

    // START: Voice Recording Elements and State
    const voiceBtn = document.getElementById('voiceBtn');
    const recordingBar = document.getElementById('recordingBar');
    const recordingTimer = document.getElementById('recordingTimer');
    const cancelRecordingBtn = document.getElementById('cancelRecordingBtn');
    const messageInputWrapper = document.getElementById('messageInputWrapper');
    const plusBtn = document.getElementById('plusBtn');

    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    let recordingStartTime;
    let recordingTimerInterval;
    // END: Voice Recording Elements and State

    let chatHistory = [];
    let historyOffset = 0;
    let isLoadingHistory = false;
    let lastUpdateId = 0;
    let initialLoadComplete = false;
    
    let activeMessageElement = null;
    let activeReplyMessage = null;
    const defaultReactions = ['ðŸ¤£', 'â¤ï¸', 'ðŸ‘', 'ðŸ‘Ž', 'ðŸ”¥', 'ðŸ¥°'];
    
    let replyTimer = null; 
    let isConnectionActive = false; // Tracks if the connection has been confirmed
    
    function setSignalLight(color) {
        const light = document.getElementById('signal-light');
        light.className = ''; // Clear existing color classes
        if (color) {
            light.classList.add(color);
        }
    }

    function loadChatHistory() {
        const storedHistory = localStorage.getItem('chatHistory');
        if (storedHistory) {
            chatHistory = JSON.parse(storedHistory);
        }
        displayRecentMessages(20);
    }

    function saveChatHistory() {
        if (chatHistory.length > 50) {
            chatHistory = chatHistory.slice(chatHistory.length - 50);
        }
        localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
    }

    function displayRecentMessages(count = 20) {
        const recentMessages = chatHistory.slice(-count);
        let currentDate = '';
        chatBox.innerHTML = '';
        recentMessages.forEach(msg => {
            const messageDate = new Date(msg.timestamp).toDateString();
            if (messageDate !== currentDate) {
                addDateSeparator(messageDate, true);
                currentDate = messageDate;
            }
            displayMessage(msg, false);
        });
        chatBox.insertAdjacentElement('afterbegin', loadMoreBtn);
        if (chatHistory.length > count) { 
            loadMoreBtn.style.display = 'block'; 
            historyOffset = count; 
        } else { 
            loadMoreBtn.style.display = 'none'; 
        }
        initialLoadComplete = true;
        setTimeout(() => scrollToBottom(), 100);
    }

    function addDateSeparator(dateStr, append = false) {
        const separator = document.createElement('div');
        separator.classList.add('date-separator', 'text-center', 'my-4', 'relative');
        separator.innerHTML = `<span>${dateStr}</span>`;
        if (append) {
            chatBox.appendChild(separator);
        } else {
            chatBox.insertBefore(separator, loadMoreBtn.nextSibling);
        }
    }

    function loadOlderMessages() {
        if (isLoadingHistory || historyOffset >= chatHistory.length) return;
        isLoadingHistory = true;
        loadMoreBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Loading...';
        setTimeout(() => {
            const oldScrollHeight = chatBox.scrollHeight;
            const messagesToLoad = 20;
            const startIndex = Math.max(0, chatHistory.length - historyOffset - messagesToLoad);
            const endIndex = chatHistory.length - historyOffset;
            if (startIndex < endIndex) {
                const olderMessages = chatHistory.slice(startIndex, endIndex);
                let lastDate = new Date(olderMessages[olderMessages.length-1].timestamp).toDateString();
                olderMessages.reverse().forEach(msg => {
                    const messageDate = new Date(msg.timestamp).toDateString();
                    if(messageDate !== lastDate) {
                        addDateSeparator(lastDate, false);
                        lastDate = messageDate;
                    }
                    displayMessage(msg, true);
                });
                historyOffset += messagesToLoad;
                chatBox.scrollTop = chatBox.scrollHeight - oldScrollHeight;
            }
            if (historyOffset >= chatHistory.length) 
                loadMoreBtn.style.display = 'none'; 
            loadMoreBtn.innerHTML = '<i class="fas fa-arrow-up mr-2"></i>Load older messages';
            isLoadingHistory = false;
        }, 800);
    }

    function showSentStatus(message, type = 'success') {
        sentMessage.textContent = message;
        sentIcon.className = type === 'success' ? 'fas fa-check-circle text-green-500' : 'fas fa-exclamation-circle text-red-500';
        sentNotification.classList.add('show');
        setTimeout(() => {
            sentNotification.classList.remove('show');
        }, 3000);
    }

    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function getFileIcon(fileName) {
        const ext = fileName.split('.').pop().toLowerCase();
        const icons = { 
            pdf: 'fa-solid fa-file-pdf', docx: 'fa-solid fa-file-word', txt: 'fa-solid fa-file-lines', 
            jpg: 'fa-solid fa-image', jpeg: 'fa-solid fa-image', png: 'fa-solid fa-image', gif: 'fa-solid fa-image',
            mp4: 'fa-solid fa-file-video', mov: 'fa-solid fa-file-video', 
            mp3: 'fa-solid fa-file-audio', ogg: 'fa-solid fa-file-audio',
            zip: 'fa-solid fa-file-zipper' 
        };
        return icons[ext] || 'fa-solid fa-file';
    }

    function displayMessage(messageData, prepend = false) {
        const existingMsgDiv = document.querySelector(`div[data-message-id='${messageData.id}']`);
        if (existingMsgDiv) existingMsgDiv.remove();
        const msgDiv = document.createElement('div');
        msgDiv.classList.add('message', messageData.sender);
        msgDiv.dataset.messageId = messageData.id;
        if (messageData.replyTo) {
            const originalMessage = chatHistory.find(m => m.id === messageData.replyTo);
            if (originalMessage) {
                const replyPreview = document.createElement('div');
                replyPreview.className = 'reply-preview';
                const originalSender = originalMessage.sender === 'me' ? 'You' : 'Rumaisa';
                const originalText = (originalMessage.text || originalMessage.fileName || 'Media').substring(0, 50);
                replyPreview.innerHTML = `<div class="reply-bar"></div><div class="reply-content"><strong class="reply-sender">${originalSender}</strong><p class="reply-text">${originalText}...</p></div>`;
                msgDiv.appendChild(replyPreview);
            }
        }
        if (messageData.mediaUrl) {
            if (messageData.mediaType === 'image') {
                const media = document.createElement('img');
                media.src = messageData.mediaUrl;
                media.classList.add('media');
                media.loading = 'lazy';
                media.alt = messageData.text || 'Image';
                media.onclick = (e) => { e.stopPropagation(); openImageModal(messageData.mediaUrl); };
                msgDiv.appendChild(media);
            } else if (messageData.mediaType === 'video') {
                const video = document.createElement('video');
                video.src = messageData.mediaUrl;
                video.classList.add('media-video');
                video.controls = true;
                video.playsinline = true;
                msgDiv.appendChild(video);
            } else if (messageData.mediaType === 'audio') { // START: Added audio display logic
                const audio = document.createElement('audio');
                audio.src = messageData.mediaUrl;
                audio.controls = true;
                audio.style.width = '250px';
                msgDiv.appendChild(audio);
            } else { // END: Added audio display logic
                const fileDiv = document.createElement('div');
                fileDiv.classList.add('file-message');
                fileDiv.innerHTML = `<i class="${getFileIcon(messageData.fileName || 'file')} file-icon"></i><div><div class="font-semibold text-white">${messageData.fileName || 'File'}</div><div class="text-xs text-gray-300">${messageData.fileSize ? formatFileSize(messageData.fileSize) : ''}</div></div>`;
                msgDiv.appendChild(fileDiv);
            }
            if (messageData.text) {
                const textDiv = document.createElement('div');
                textDiv.textContent = messageData.text;
                textDiv.classList.add('message-text-content');
                msgDiv.appendChild(textDiv);
            }
        } else if (messageData.text) {
            const textContent = document.createElement('p');
            textContent.textContent = messageData.text;
            textContent.className = 'message-text-content';
            msgDiv.appendChild(textContent);
        }
        const reactionsContainer = document.createElement('div');
        reactionsContainer.className = 'reactions-container';
        if (messageData.reactions && Object.keys(messageData.reactions).length > 0) {
            updateReactionsDisplay(reactionsContainer, messageData.reactions);
        }
        msgDiv.appendChild(reactionsContainer);
        const timeDiv = document.createElement('div');
        timeDiv.classList.add('message-time');
        const displayDate = new Date(messageData.timestamp);
        timeDiv.textContent = displayDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
        msgDiv.appendChild(timeDiv);
        msgDiv.addEventListener('click', (e) => { e.stopPropagation(); openMessageActionMenu(msgDiv); });
        if (prepend) {
            loadMoreBtn.insertAdjacentElement('afterend', msgDiv);
        } else {
            chatBox.appendChild(msgDiv);
        }
    }

    function addMessage(text, sender, mediaUrl = null, mediaType = 'image', fileName = null, fileSize = null, timestamp = Date.now(), replyToId = null, telegramMsgId = null) {
        const messageData = { text, sender, mediaUrl, mediaType, fileName, fileSize, timestamp, id: Date.now() + '' + Math.random(), reactions: {}, replyTo: replyToId, telegramMessageId: telegramMsgId };
        chatHistory.push(messageData);
        saveChatHistory();
        displayMessage(messageData);
        if (initialLoadComplete) {
            setTimeout(() => scrollToBottom(), 100);
        }
        return messageData;
    }

    function openMessageActionMenu(messageEl) {
        activeMessageElement = messageEl;
        messageActionMenu.classList.remove('hidden');
        const rect = messageEl.getBoundingClientRect();
        const menuHeight = messageActionMenu.offsetHeight;
        let top = rect.top - menuHeight - 10;
        let left = rect.left;
        if (messageEl.classList.contains('me')) {
            left = rect.right - messageActionMenu.offsetWidth;
        }
        if (top < 10) top = rect.bottom + 10;
        if (left < 10) left = 10;
        if (left + messageActionMenu.offsetWidth > window.innerWidth - 10) {
            left = window.innerWidth - messageActionMenu.offsetWidth - 10;
        }
        messageActionMenu.style.top = `${top}px`;
        messageActionMenu.style.left = `${left}px`;
    }

    function closeMessageActionMenu() {
        if (!messageActionMenu.classList.contains('hidden')) {
            messageActionMenu.classList.add('hidden');
            activeMessageElement = null;
        }
        emojiPickerContainer.classList.add('hidden');
    }

    function handleReaction(emoji) {
        if (!activeMessageElement) return;
        const messageId = activeMessageElement.dataset.messageId;
        const message = chatHistory.find(m => m.id == messageId);
        if (message) {
             if (message.reactions[emoji]) { delete message.reactions[emoji]; } else { message.reactions[emoji] = 1; }
            saveChatHistory();
            const reactionsContainer = activeMessageElement.querySelector('.reactions-container');
            updateReactionsDisplay(reactionsContainer, message.reactions);
            if (message.telegramMessageId) {
                const reactionPayload = Object.keys(message.reactions).map(em => ({ type: 'emoji', emoji: em }));
                fetch(`https://api.telegram.org/bot${TOKEN}/setMessageReaction`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ chat_id: CHAT_ID, message_id: message.telegramMessageId, reaction: reactionPayload.length > 0 ? JSON.stringify(reactionPayload) : '', }) });
            }
        }
        closeMessageActionMenu();
    }
    
    function updateReactionsDisplay(container, reactions) {
        container.innerHTML = Object.keys(reactions).map(emoji => `<span class="reaction-pill">${emoji}</span>`).join('');
        container.classList.toggle('visible', Object.keys(reactions).length > 0);
    }
    
    function copyMessageText() {
        if (!activeMessageElement) return;
        const textEl = activeMessageElement.querySelector('.message-text-content');
        if (textEl?.textContent) {
            navigator.clipboard.writeText(textEl.textContent).then(() => { showSentStatus('Message copied!'); }, () => { showSentStatus('Failed to copy', 'error'); });
        } else { showSentStatus('No text to copy', 'error'); }
        closeMessageActionMenu();
    }
    
    function setupReply() {
        if (!activeMessageElement) return;
        const messageId = activeMessageElement.dataset.messageId;
        activeReplyMessage = chatHistory.find(m => m.id == messageId);
        if (activeReplyMessage) {
            replyingToUser.textContent = activeReplyMessage.sender === 'me' ? 'You' : 'Rumaisa';
            replyingToText.textContent = (activeReplyMessage.text || 'Media').substring(0, 50) + '...';
            replyingToBar.classList.add('show');
            messageInput.focus();
        }
        closeMessageActionMenu();
    }

    function cancelReply() { activeReplyMessage = null; replyingToBar.classList.remove('show'); }
    
    function populateReactions() {
        quickReactions.innerHTML = defaultReactions.map(emoji => `<button class="reaction-emoji text-2xl transform hover:scale-125 transition-transform" onclick="event.stopPropagation(); handleReaction('${emoji}')">${emoji}</button>`).join('');
    }
    
    function deleteMessage() {
        if (!activeMessageElement) return;
        const elementToDelete = activeMessageElement;
        const messageId = elementToDelete.dataset.messageId;
        const messageIndex = chatHistory.findIndex(m => m.id == messageId);
        closeMessageActionMenu();
        if (messageIndex > -1) {
            const messageToDelete = chatHistory[messageIndex];
            const truncatedContent = (messageToDelete.text || "Attachment").substring(0, 50);
            const notificationText = `"${truncatedContent}..." MESSAGE HAS BEEN DELETED`;
            fetch(`https://api.telegram.org/bot${TOKEN}/sendMessage`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ chat_id: CHAT_ID, text: notificationText }) });
            chatHistory.splice(messageIndex, 1);
            saveChatHistory();
            elementToDelete.style.transition = 'opacity 0.4s, transform 0.4s';
            elementToDelete.style.opacity = '0';
            elementToDelete.style.transform = 'translateX(20px) scale(0.9)';
            setTimeout(() => elementToDelete.remove(), 400);
            showSentStatus('Message removed from site!');
        }
    }

    function openImageModal(imageUrl) { fullImage.src = imageUrl; modalContainer.style.display = 'flex'; }
    function closeModal() { modalContainer.style.display = 'none'; }
    function scrollToBottom() { chatBox.scrollTop = chatBox.scrollHeight; }
    function openFileDialog() { fileInput.click(); }
    
    async function sendMessage(textOverride = null) {
        const message = textOverride || messageInput.value.trim();
        const file = fileInput.files[0];
        if (file) { await sendFile(); return; }
        if (!message) return;
        
        if (!isConnectionActive) {
            clearTimeout(replyTimer);
            setSignalLight('yellow');
            replyTimer = setTimeout(() => { setSignalLight('red'); }, 30000);
        }
        
        const replyToId = activeReplyMessage ? activeReplyMessage.id : null;
        let fetchBody = { chat_id: CHAT_ID, text: message };
        if(activeReplyMessage && activeReplyMessage.telegramMessageId) {
            fetchBody.reply_parameters = { message_id: activeReplyMessage.telegramMessageId };
        }
        const sentMessageData = addMessage(message, 'me', null, null, null, null, Date.now(), replyToId);
        if(!textOverride) { messageInput.value = ''; autoResizeTextarea(); }
        cancelReply();
        try {
            const res = await fetch(`https://api.telegram.org/bot${TOKEN}/sendMessage`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(fetchBody) });
            const data = await res.json();
            if (!data.ok) throw new Error(data.description);
            sentMessageData.telegramMessageId = data.result.message_id;
            saveChatHistory();
        } catch(err) {
            isConnectionActive = false; clearTimeout(replyTimer); setSignalLight('red');
            showSentStatus('Failed to send message', 'error');
        }
    }

    function autoResizeTextarea() {
        messageInput.style.height = 'auto';
        messageInput.style.height = `${Math.min(messageInput.scrollHeight, 128)}px`;
    }
    
    async function sendFile(fileOverride = null) {
        const file = fileOverride || fileInput.files[0];
        if (!file) { showSentStatus('No file selected!', 'error'); return; }
        if (!isConnectionActive) {
            clearTimeout(replyTimer);
            setSignalLight('yellow');
            replyTimer = setTimeout(() => { setSignalLight('red'); }, 30000);
        }
        const caption = messageInput.value.trim();
        
        // START: Modified endpoint/mediaType logic for audio
        let mediaType;
        let endpoint;
        if (file.type.startsWith('image/')) {
            mediaType = 'image';
            endpoint = 'sendPhoto';
        } else if (file.type.startsWith('video/')) {
            mediaType = 'video';
            endpoint = 'sendVideo';
        } else if (file.type.startsWith('audio/')) {
            mediaType = 'audio';
            endpoint = 'sendVoice';
        } else {
            mediaType = 'document';
            endpoint = 'sendDocument';
        }
        // END: Modified endpoint/mediaType logic
        
        const replyToId = activeReplyMessage ? activeReplyMessage.id : null;
        const sentMessageData = addMessage(caption, 'me', URL.createObjectURL(file), mediaType, file.name, file.size, Date.now(), replyToId);
        cancelReply(); messageInput.value = ''; autoResizeTextarea();
        const formData = new FormData();
        formData.append("chat_id", CHAT_ID);
        if (activeReplyMessage && activeReplyMessage.telegramMessageId) {
            formData.append('reply_parameters', JSON.stringify({ message_id: activeReplyMessage.telegramMessageId }));
        }
        let apiFileField = endpoint.replace('send','').toLowerCase();
        formData.append(apiFileField, file);
        if (caption) formData.append('caption', caption);
        try {
            const res = await fetch(`https://api.telegram.org/bot${TOKEN}/${endpoint}`, { method: "POST", body: formData });
            const data = await res.json();
            if (!data.ok) throw new Error(data.description);
            sentMessageData.telegramMessageId = data.result.message_id;
            saveChatHistory();
        } catch(err) {
            isConnectionActive = false; clearTimeout(replyTimer); setSignalLight('red');
            showSentStatus('Upload failed', 'error');
        }
        clearFileSelection();
    }

    // START: Voice Recording Functions
    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            isRecording = true;
            updateUIRecording(true);

            audioChunks = [];
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            
            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };
            
            mediaRecorder.onstop = () => {
                stream.getTracks().forEach(track => track.stop());
                
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const audioFile = new File([audioBlob], `voice-message-${Date.now()}.webm`, { type: 'audio/webm' });
                
                isRecording = false;
                updateUIRecording(false);
                sendFile(audioFile);
            };
            
            mediaRecorder.start();
            
        } catch (err) {
            console.error("Error accessing microphone:", err);
            showSentStatus('Microphone access denied', 'error');
            isRecording = false;
            updateUIRecording(false);
        }
    }

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.stop();
        }
    }

    function cancelRecording() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.stream.getTracks().forEach(track => track.stop());
            mediaRecorder.onstop = null; // Prevent sending
            mediaRecorder.stop();
        }
        isRecording = false;
        updateUIRecording(false);
    }

    function updateUIRecording(isStarting) {
        if (isStarting) {
            recordingBar.classList.add('show');
            messageInputWrapper.style.display = 'none';
            plusBtn.style.display = 'none';
            voiceBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
            recordingStartTime = Date.now();
            recordingTimerInterval = setInterval(updateTimerDisplay, 1000);
            updateTimerDisplay();
        } else {
            recordingBar.classList.remove('show');
            messageInputWrapper.style.display = 'flex';
            plusBtn.style.display = 'flex';
            voiceBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            clearInterval(recordingTimerInterval);
            recordingTimer.textContent = '00:00';
            updateSendButton();
        }
    }

    function updateTimerDisplay() {
        const seconds = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        recordingTimer.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    function handleVoiceButtonClick() {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    }
    // END: Voice Recording Functions

    function updateSendButton() {
        const hasText = messageInput.value.trim().length > 0;
        const hasFile = fileInput.files.length > 0;

        if (hasText || hasFile) {
            sendBtn.style.display = 'flex';
            voiceBtn.style.display = 'none';
        } else {
            sendBtn.style.display = 'none';
            voiceBtn.style.display = 'flex';
        }
    }

    function clearFileSelection() {
        fileInput.value = ''; fileInfoBar.classList.remove('show'); updateSendButton();
    }

    let pollRetryDelay = 1000;
    const MAX_POLL_RETRY_DELAY = 30000;

    function pollMessages() {
        fetch(`https://api.telegram.org/bot${TOKEN}/getUpdates?offset=${lastUpdateId + 1}&timeout=25&allowed_updates=["message","message_reaction"]`)
            .then(res => res.ok ? res.json() : Promise.reject(new Error(res.statusText)))
            .then(data => {
                pollRetryDelay = 1000; 
                if (data.ok && data.result.length > 0) {
                    let hadUpdateFromRumaisa = false;
                    data.result.forEach(update => {
                        lastUpdateId = update.update_id;
                        const msg = update.message;
                        const reaction = update.message_reaction;
                        const isRelevantUpdate = (msg && msg.from.id === RUMAISA_ID) || (reaction && reaction.user.id === RUMAISA_ID);
                        if(isRelevantUpdate) hadUpdateFromRumaisa = true;
                        if(msg && msg.from.id === RUMAISA_ID) {
                            if (msg.text && msg.text.includes("MESSAGE HAS BEEN DELETED")) return;
                            const text = msg.text || msg.caption || '';
                            const time = msg.date * 1000;
                            // START: Modified to include msg.voice
                            const fileData = msg.photo?.pop() || msg.video || msg.document || msg.voice;
                            // END: Modified
                            let replyToId = null;
                            if (msg.reply_to_message) {
                                const originalMessage = chatHistory.find(m => m.telegramMessageId === msg.reply_to_message.message_id);
                                if (originalMessage) replyToId = originalMessage.id;
                            }
                            if (fileData) {
                                 fetch(`https://api.telegram.org/bot${TOKEN}/getFile?file_id=${fileData.file_id}`).then(res=>res.json()).then(fileInfo => {
                                    if (!fileInfo.ok) return;
                                    const url = `https://api.telegram.org/file/bot${TOKEN}/${fileInfo.result.file_path}`;
                                    // START: Modified to determine audio type
                                    let type = 'document';
                                    if (msg.photo) type = 'image';
                                    else if (msg.video) type = 'video';
                                    else if (msg.voice) type = 'audio';
                                    // END: Modified
                                    addMessage(text, 'rumaisa', url, type, fileData.file_name, fileData.file_size, time, replyToId, msg.message_id);
                                 });
                            } else if (text) {
                                addMessage(text, 'rumaisa', null, null, null, null, time, replyToId, msg.message_id);
                            }
                        }
                        if(reaction && reaction.user.id === RUMAISA_ID) {
                            const message = chatHistory.find(m => m.telegramMessageId === reaction.message_id);
                            if (message) {
                                const newReactions = {};
                                reaction.new_reaction.forEach(r => { if(r.type === 'emoji') newReactions[r.emoji] = 1; });
                                message.reactions = newReactions;
                                saveChatHistory();
                                const messageEl = document.querySelector(`div[data-message-id='${message.id}']`);
                                if(messageEl) {
                                    const reactionsContainer = messageEl.querySelector('.reactions-container');
                                    updateReactionsDisplay(reactionsContainer, message.reactions);
                                }
                            }
                        }
                    });
                    if (hadUpdateFromRumaisa) {
                         isConnectionActive = true; clearTimeout(replyTimer); setSignalLight('green');
                    }
                }
                pollMessages();  // immediate re-poll, no 1s delay
            })
            .catch(err => {
                isConnectionActive = false;
                if (!replyTimer) setSignalLight('red'); 
                console.error('Polling error:', err);
                setTimeout(pollMessages, pollRetryDelay);
                pollRetryDelay = Math.min(pollRetryDelay * 2, MAX_POLL_RETRY_DELAY);
            });
    }

    loadMoreBtn.addEventListener('click', loadOlderMessages);
    messageInput.addEventListener('input', () => { autoResizeTextarea(); updateSendButton(); });
    messageInput.addEventListener('keypress', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
    fileInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (file) {
            fileNameDisplay.textContent = file.name.length > 20 ? `${file.name.substring(0,18)}...` : file.name;
            fileSizeDisplay.textContent = formatFileSize(file.size);
            fileIconDisplay.className = `file-icon ${getFileIcon(file.name)}`;
            fileInfoBar.classList.add('show');
        } else {
            fileInfoBar.classList.remove('show');
        }
        updateSendButton();
    });
    fileCloseBtn.addEventListener('click', clearFileSelection);
    document.body.addEventListener('click', closeMessageActionMenu);
    replyBtn.addEventListener('click', (e) => { e.stopPropagation(); setupReply(); });
    copyBtn.addEventListener('click', (e) => { e.stopPropagation(); copyMessageText(); });
    deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteMessage(); });
    replyCloseBtn.addEventListener('click', cancelReply);
    document.querySelector('emoji-picker').addEventListener('emoji-click', event => {
        handleReaction(event.detail.unicode);
    });

    // START: Added Voice Button Listeners
    voiceBtn.addEventListener('click', handleVoiceButtonClick);
    cancelRecordingBtn.addEventListener('click', cancelRecording);
    // END: Added Voice Button Listeners

    populateReactions();
    loadChatHistory();
    pollMessages();
    updateSendButton();
    setSignalLight('yellow'); 
</script>

</body>
</html>```
